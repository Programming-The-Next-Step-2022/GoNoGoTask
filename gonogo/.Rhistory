#'
#' @return Response (either choice key pressed, or NA) and reaction time in seconds (NA if choice key not pressed)
#' @export
#'
#' @examples
rrt <- function(choiceKeys=c(" "), interval = 0.6) {
dynamic_readline <- function() {
# Create a counter variable that breaks the loop
x <- 0
while (rstudioapi::isAvailable()) {
input <- rstudioapi::getConsoleEditorContext()$contents
# Increase counter variable
>>>>>>> Stashed changes
x <- x + 1
if (input != "") {
rstudioapi::sendToConsole("", execute = FALSE)
return(input)
}
if (x == 5) {
return("none")
}
}
readline()
}
<<<<<<< Updated upstream
rt <- Sys.time()
repeat {
choice <- dynamic_readline()
if (choice %in% choiceKeys) {
rt <- Sys.time() - rt
break
}
elapsed_time <- Sys.time() - rt
if (elapsed_time > interval) {
rt <- NA
break
}
}
setNames(c(choice, rt), c("response", "rt"))
}
update_data <- function(data, stimuli = stimuli) {
# Replace " " with "space"
for (i in 1:nrow(data)) {
if (data$response[i] == " ") {
data$response[i] <- "space"
}
}
# Subtract the mean error (time it takes to run the function rrt() from a
# simulation of 1000 trials) from the reaction times for increased accuracy
mean_error <- 0.02742448
data$rt <- as.numeric(data$rt)
for (i in 1:nrow(data)) {
if (!is.na(data$rt[i])) { # think about the second condition
data[i, "rt"] <- data[i, "rt"]-mean_error
}
}
# Update the correct and SDT columns
for (i in 1:nrow(data)) {
if (data[i, "stimulus"] == stimuli[1] && data[i, "response"] == "space") {
data[i, "correct"] <- 1
data[i, "SDT"] <- "hit"
} else if (data[i, "stimulus"] == stimuli[2] && data[i, "response"] == "space") {
data[i, "correct"] <- 0
data[i, "SDT"] <- "falsealarm"
} else if (data[i, "stimulus"] == stimuli[1] && data[i, "response"] != "space") {
data[i, "correct"] <- 0
data[i, "SDT"] <- "miss"
} else {
data[i, "correct"] <- 1
data[i, "SDT"] <- "correctrejection"
}
}
return(data)
}
gonogo <- function(id, n_trial = 40, n_block = 4, stimuli = c("A", "X"),
inter = 0.6, prb = c(0.75, 0.25)) {
# Check class and length of arguments
if (!(class(id) %in% c("character", "numeric")) || length(id) != 1) {
stop("id must be either a numeric vector of length 1 (pin number identifying the participant), or a character vector of length 1 (name of participant)")
}
if (class(n_trial) != "numeric" || length(n_trial) != 1) {
stop("n_trial must be a numeric vector of length 1")
}
if (class(n_block) != "numeric" || length(n_block) != 1) {
stop("n_block must be a numeric vector of length 1")
}
if (class(stimuli) != "character" || length(stimuli) != 2) {
stop("stimuli must be a character vector of length 2")
}
if (class(inter) != "numeric" || length(inter) != 1) {
stop("inter must be a numeric vector of length 1")
}
if (class(prb) != "numeric" || length(prb) != 2 || prb[1] + prb[2] != 1) {
stop("prb must be a numeric vector of length 2, and its components must add up to 1")
}
# Create practice stimuli
practice <- sample(x = stimuli, size = 10, replace = TRUE)
# Create separate dataframes for each block
all_data <- list()
for (j in 1:n_block) {
all_data[[j]] <- data.frame(id = factor(rep(id, n_trial),
levels = c(id)),
response = factor(rep("none", n_trial),
levels = c(" ",
"none",
"space")),
correct = rep(2, n_trial),
SDT = factor(rep("hit", n_trial),
levels = c("hit",
"miss",
"falsealarm",
"correctrejection")),
rt = rep(100, n_trial),
stimulus = sample(x = stimuli,
size = n_trial,
prob = prb,
replace = TRUE),
block = rep(j, n_trial)
)
}
# Intro screens
drawScreen(paste("Welcome to the Go-No Go Task", id,"!\nPress Enter to continue."), cex = 1.3)
readline()
drawScreen(paste("Instructions \nIn this task, you will see two types of stimuli,", stimuli[1], "and\n", stimuli[2], ". When you see", stimuli[1], "you should respond as quickly as\npossible by pressing the space bar. When you see", stimuli[2], "you should\nnot respond (do not press any key). You should try to be as fast and accurate\nas possible. Press Enter to continue."),
cex = 0.75)
readline()
drawScreen(paste("The task consists of", n_block, "blocks, each consisting of", n_trial, "trials.\nThere is is a break between each pair of blocks.\nBefore starting the task, there is one practice block of 10 trials.\n Press Enter to start the practice trials."),
cex = 0.75)
readline()
drawScreen("")
Sys.sleep(0.5)
# Practice trials
drawScreen("Practice trials")
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (p in 1:10) {
drawScreen(practice[p], 3)
rrt(choiceKeys = c(" "), interval = inter)
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
drawScreen("")
Sys.sleep(0.1)
}
drawScreen("End of practice trials.\nPress Enter to continue on to the task.",
cex = 1)
readline()
# The for loops
for (j in 1:n_block) {
drawScreen(paste("Block", j))
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (i in 1:n_trial) {
drawScreen(all_data[[j]][i, "stimulus"], 3)
all_data[[j]][i, c("response", "rt")] <- rrt(choiceKeys = c(" "),
interval = inter)
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
drawScreen("")
Sys.sleep(0.1)
}
drawScreen(paste("End of Block", j, "!\n Press Enter to continue."),
cex = 1)
readline()
}
# End screen
drawScreen(paste("You finished the task. Thank you for participating",id,"!"), cex = 1)
# Bind the datasets
for (k in 1:(length(all_data)-1)) {
all_data[[k+1]] <- rbind(all_data[[k]], all_data[[k+1]])
}
data <- all_data[[length(all_data)]]
# Update the dataset
data <- update_data(data, stimuli = stimuli)
print(data)
}
# Ideas?
# can you break up the function into smaller bits?
# make code prettier
# specify what rt=NA means / how it works
# function for detecting unrealistic reaction times after data set is done? / message?
# function for changing the data set (last bit of code)?
# change all documentation + testing
# delete the rrt_mean_error function
gonogo(id = "Milla", n_trial = 10, n_block = 3, inter = 0.5)
gonogo(id = "Milla", n_trial = 10, n_block = 3)
gonogo <- function(id, n_trial = 40, n_block = 4, stimuli = c("A", "X"),
inter = 0.6, prb = c(0.75, 0.25)) {
# Check class and length of arguments
if (!(class(id) %in% c("character", "numeric")) || length(id) != 1) {
stop("id must be either a numeric vector of length 1 (pin number identifying the participant), or a character vector of length 1 (name of participant)")
}
if (class(n_trial) != "numeric" || length(n_trial) != 1) {
stop("n_trial must be a numeric vector of length 1")
}
if (class(n_block) != "numeric" || length(n_block) != 1) {
stop("n_block must be a numeric vector of length 1")
}
if (class(stimuli) != "character" || length(stimuli) != 2) {
stop("stimuli must be a character vector of length 2")
}
if (class(inter) != "numeric" || length(inter) != 1) {
stop("inter must be a numeric vector of length 1")
}
if (class(prb) != "numeric" || length(prb) != 2 || prb[1] + prb[2] != 1) {
stop("prb must be a numeric vector of length 2, and its components must add up to 1")
}
# Create practice stimuli
practice <- sample(x = stimuli, size = 10, replace = TRUE)
# Create separate dataframes for each block
all_data <- list()
for (j in 1:n_block) {
all_data[[j]] <- data.frame(id = factor(rep(id, n_trial),
levels = c(id)),
response = factor(rep("none", n_trial),
levels = c(" ",
"none",
"space")),
correct = rep(2, n_trial),
SDT = factor(rep("hit", n_trial),
levels = c("hit",
"miss",
"falsealarm",
"correctrejection")),
rt = rep(100, n_trial),
stimulus = sample(x = stimuli,
size = n_trial,
prob = prb,
replace = TRUE),
block = rep(j, n_trial)
)
}
# Intro screens
drawScreen(paste("Welcome to the Go-No Go Task", id,"!\nPress Enter to continue."), cex = 1.3)
readline()
drawScreen(paste("Instructions \nIn this task, you will see two types of stimuli,", stimuli[1], "and\n", stimuli[2], ". When you see", stimuli[1], "you should respond as quickly as\npossible by pressing the space bar. When you see", stimuli[2], "you should\nnot respond (do not press any key). You should try to be as fast and accurate\nas possible. Press Enter to continue."),
cex = 0.75)
readline()
drawScreen(paste("The task consists of", n_block, "blocks, each consisting of", n_trial, "trials.\nThere is is a break between each pair of blocks.\nBefore starting the task, there is one practice block of 10 trials.\n Press Enter to start the practice trials."),
cex = 0.75)
readline()
drawScreen("")
Sys.sleep(0.5)
# Practice trials
drawScreen("Practice trials")
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (p in 1:10) {
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
drawScreen("")
Sys.sleep(0.1)
drawScreen(practice[p], 3)
rrt(choiceKeys = c(" "), interval = inter)
}
drawScreen("End of practice trials.\nPress Enter to continue on to the task.",
cex = 1)
readline()
# The for loops
for (j in 1:n_block) {
drawScreen(paste("Block", j))
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (i in 1:n_trial) {
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
drawScreen("")
Sys.sleep(0.1)
drawScreen(all_data[[j]][i, "stimulus"], 3)
all_data[[j]][i, c("response", "rt")] <- rrt(choiceKeys = c(" "),
interval = inter)
}
drawScreen(paste("End of Block", j, "!\n Press Enter to continue."),
cex = 1)
readline()
}
# End screen
drawScreen(paste("You finished the task. Thank you for participating",id,"!"), cex = 1)
# Bind the datasets
for (k in 1:(length(all_data)-1)) {
all_data[[k+1]] <- rbind(all_data[[k]], all_data[[k+1]])
}
data <- all_data[[length(all_data)]]
# Update the dataset
data <- update_data(data, stimuli = stimuli)
print(data)
}
gonogo(id = 12, n_trial = 5, n_block = 3)
devtools::document()
devtools::document()
devtools::load_all()
devtools::build()
devtools::load_all()
gonogo(id = "Milla", n_trial = 20, n_block = 2)
data<-gonogo(id = "Milla")
dtaa$rt
data$rt
hist(data$rt)
sort(daya$rt)
sort(data$rt)
which(data$rt < 0)
sort(data$rt)
is.na(data$rt)
sum(is.na(data$rt))
sum(!is.na(data$rt))
sort(data$rt)
(-0.018445636) + 0.014460470
0.018445636 - 0.014460470
sort(data$rt)[1]
i<-1
abs(abs(sort(data$rt)[i+1]) - abs(sort(data$rt)[i]))
i<-10
abs(abs(sort(data$rt)[i+1]) - abs(sort(data$rt)[i]))
range(data$rt)
range(data$rt, na.rm = T)
-0.003249551 - 0.337513541
range(data$rt, na.rm = TRUE)
abs(range(data$rt, na.rm = TRUE)[1] - range(data$rt, na.rm = TRUE)[2])
threshold <- 1/3 * abs(range(data$rt, na.rm = TRUE)[1] - range(data$rt, na.rm = TRUE)[2])
abs(range(data$rt, na.rm = TRUE)[1] - range(data$rt, na.rm = TRUE)[2])
threshold <- 1/3 * abs(range(data$rt, na.rm = TRUE)[1] - range(data$rt, na.rm = TRUE)[2])
dist <- c()
for (i in 1:(sum(!is.na(data$rt))-1)) {
dist[i] <- abs(sort(data$rt)[i+1] - sort(data$rt)[i])
}
sum(dist >= threshold)
dist
whihc(dist >= threshold)
which(dist >= threshold)
dist[4]
(sum(data$rt < 0))
(sum(data$rt < 0, na.rm = TRUE))
which(data$rt < 0)
hist(dist)
hist(dist[-4])
?gonogo
?gonogo::gonogo
devtools::document()
devtools::build()
devtools::load_all()
devtools::load_all()
devtools::load_all()
=======
o_rt <- Sys.time()
repeat {
choice <- dynamic_readline()
if (choice %in% choiceKeys){
o_rt <- Sys.time() - o_rt
break
}
elapsed_time <- Sys.time() - o_rt
if (elapsed_time > interval) {
o_rt <- 100
break
}
}
setNames(c(choice, o_rt), c("response", "rt"))
}
rrt()
rrt()
library(shiny); runApp('C:/Users/Omistaja/AppData/Local/Packages/microsoft.windowscommunicationsapps_8wekyb3d8bbwe/LocalState/Files/S0/24543/Attachments/shiny_example_rt[28023].R')
runApp('R/shiny_attempt.R')
runApp('R/shiny_attempt.R')
runApp('R/shiny_attempt.R')
# Game parameters (don't think these should be set beforehand though? I want participant to decide on them)
interval <- 0.6
n_trial <- 10
prb <- c(0.7, 0.3)
stim <- c("A", "X")
stimuli <- sample(stim, size = n_trial, replace = TRUE)
runApp('R/shiny_attempt.R')
interval <- 0.6
n_trial <- 10
prb <- c(0.7, 0.3)
stim <- c("A", "X")
stimuli <- sample(stim, size = n_trial, replace = TRUE)
ui <- fixedPage(
title = "Go No-Go Task",
uiOutput("MainAction"),
#tags$style(type = "text/css", ".recalculating {opacity: 1.0;}") # prevents grey screen during Sys.sleep()
)
server <- function(input, output, session) {
# Define Reactive Values (the main values in the game)
CurrentValues <- reactiveValues(page = "welcome",
training = TRUE,
lastPress = Sys.time(),
trial = 0,
rt = 0,
stimulus = NULL,
response = NULL)
# GameData stores vectors of histories
GameData <- reactiveValues(trial = c(),
rt = c(),
stimulus = c(),
lastPress = c(),
response = c())
# Page Layout
PageLayouts <- reactive({
# Welcome page
if (CurrentValues$page == "welcome") {
inputLabel <- p("Please enter your name or a unique ID")
}
return(
list(
h1("Go No-Go Task"),
p("This is a version of the Go-No Go Task implemented in Shiny. The task measures inhibitory control, a cognitive process that enables humans to cancel motor activity after its initiation."),
p("If you wish to continue, please enter your name or a unique ID number"),
textInput(inputId = "workerid",
label = inputLabel,
placeholder = "e.g., participant 1"),
actionButton(inputId = "gt_inst1",
label = "Start!")
)
)
# Instructions
if (CurrentValues$page == "inst1") {
return(
list(
h1("The Go-No Go Task"),
p("Some instructions go here"),
actionButton(inputId = "gt_training",
label = "Start the task")
)
)}
}
# Game
# if (currentValues$page == "game") {
#
# }
)
}
# server <- function(input, output, session) {
#
#   click_timestamps <- reactiveVal(NULL)
#   recorded_rts <- reactiveVal(NULL)
#
#   observeEvent(input$button, {
#     new_val <- append(click_timestamps(), Sys.time())
#
#     # set click timestamp
#     click_timestamps(new_val)
#
#     if(length(new_val) == 2) {
#
#       duration <- as.numeric(difftime(new_val[2], new_val[1], units = "secs"))
#       recorded_rts(c(recorded_rts(), duration))
#
#       print(recorded_rts)
#       print(click_timestamps)
#
#       # reset click timestamp
#       click_timestamps(NULL)
#     }
#   })
#
#   output$table <- renderTable(
#     if (length(recorded_rts()) > 0) {
#       return(data.frame(n = seq_along(recorded_rts()), rt = recorded_rts()))
#     } else {
#       return(data.frame(n = "-", rt = "-"))
#     }
#
#   )
#   output$plot <- renderPlot(
#     if (length(recorded_rts()) > 0)
#       hist(recorded_rts())
#     else
#       plot(1, type="n", xlab="", ylab="", xlim=c(0, 10), ylim=c(0, 10))
#   )
#
# }
#
shinyApp(ui, server)
devtools::load_
devtools::load_all()
devtools::build()
>>>>>>> Stashed changes
