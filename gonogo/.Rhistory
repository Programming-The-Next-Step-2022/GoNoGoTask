<<<<<<< Updated upstream
"miss",
"falsealarm",
"correctrejection")),
rt = rep(100, n_trial),
stimulus = sample(x = stimuli,
size = n_trial,
prob = prb,
replace = TRUE),
block = rep(j, n_trial)
)
}
# Intro screens
drawScreen(paste("Welcome to the Go-No Go Task", id,"!\nPress Enter to continue."), cex = 1.3)
readline()
drawScreen(paste("Instructions \nIn this task, you will see two types of stimuli,", stimuli[1], "and\n", stimuli[2], ". When you see", stimuli[1], "you should respond as quickly as\npossible by pressing the space bar. When you see", stimuli[2], "you should\nnot respond (do not press any key). You should try to be as fast and accurate\nas possible. Press Enter to continue."),
cex = 0.75)
readline()
drawScreen(paste("The task consists of", n_block, "blocks, each consisting of", n_trial, "trials.\nThere is is a break between each pair of blocks.\nBefore starting the task, there is one practice block of 10 trials.\n Press Enter to start the practice trials."),
cex = 0.75)
readline()
drawScreen("")
Sys.sleep(0.5)
# Practice trials
drawScreen("Practice trials")
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (p in 1:10) {
print(p)
drawScreen(practice[p], 3)
rrt(choiceKeys = c(" "), interval = inter)
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
}
drawScreen("End of practice trials.\nPress Enter to continue on to the task.",
cex = 1)
readline()
# The for loops
for (j in 1:n_block) {
drawScreen(paste("Block", j))
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (i in 1:n_trial) {
print(i)
drawScreen(all_data[[j]][i, "stimulus"], 3)
all_data[[j]][i, c("response", "rt")] <- rrt(choiceKeys = c(" "),
interval = inter)
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
}
drawScreen(paste("End of Block", j, "!\n Press Enter to continue."),
cex = 1)
readline()
}
# End screen
drawScreen(paste("You finished the task. Thank you for participating",id,"!"), cex = 1)
# Bind the datasets
for (k in 1:(length(all_data)-1)) {
all_data[[k+1]] <- rbind(all_data[[k]], all_data[[k+1]])
}
data <- all_data[[length(all_data)]]
print(data)
str(data)
# Update the dataset
data <- update_data(data, stimuli = stimuli)
# Update the dataset
# for (rows in 1:nrow(data)) {
#   if (data[rows, "stimulus"] == stimuli[1] && data[rows, "response"] == " ") {
#     data[rows, "correct"] <- 1
#     data[rows, "SDT"] <- "hit"
#   } else if (data[rows, "stimulus"] == stimuli[2] && data[rows, "response"] == " ") {
#     data[rows, "correct"] <- 0
#     data[rows, "SDT"] <- "falsealarm"
#   } else if (data[rows, "stimulus"] == stimuli[1] && data[rows, "response"] != " ") {
#     data[rows, "correct"] <- 0
#     data[rows, "SDT"] <- "miss"
#   } else {
#     data[rows, "correct"] <- 1
#     data[rows, "SDT"] <- "correctrejection"
#   }
# }
#
# data$rt <- as.numeric(data$rt)
# for (rows in 1:nrow(data)) {
#   if (data$rt[rows] == 100) {
#     data$rt[rows] <- NA
#   }
# }
#
# for (rows in 1:nrow(data)) {
#   if (data$response[rows] == " ") {
#     data$response[rows] <- "space"
#   }
# }
#
# for (rows in 1:nrow(data)) {
#   if (!is.na(data$rt[rows]) && data$rt[rows] > mean_error) { # think about the second condition
#     data[rows, "rt"] <- data[rows, "rt"]-mean_error
#   }
# }
print(data)
}
# Ideas?
# can you break up the function into smaller bits?
# make code prettier
# specify what rt=NA means / how it works
# function for detecting unrealistic reaction times after data set is done? / message?
# function for changing the data set (last bit of code)?
# change all documentation + testing
# delete the rrt_mean_error function
gonogo(id = "Milla", n_trial = 5, n_block = 3)
drawScreen <- function(txt, cex = 1, col = "black") {
if (class(txt) != "character" || length(txt) != 1) {
stop("txt must be a character vector of length 1")
}
if (class(cex) != "numeric" || length(cex) != 1) {
stop("cex must be a numeric vector of length 1")
}
if (class(col) != "character" || sum("black" == colours()) != 1) {
stop("col must be a character vector of length 1, and it must match with one element of the built-in colours that R knows about")
}
plot(x = NA, y = NA,
xlim = c(0, 1), ylim = c(0, 1),
xaxt = "n", yaxt = "n",
xlab = "", ylab = "")
text(x = 0.5, y = 0.5, labels = txt, cex = cex)
}
rrt <- function(choiceKeys = c(" "), interval = 0.6) {
dynamic_readline <- function() {
x <- 0
while (rstudioapi::isAvailable()) {
input <- rstudioapi::getConsoleEditorContext()$contents
=======
9*6+7.5*6+8*6+9.5*6+10*6+10*3+9*3+8.5*3
346.5/39
9*6+7.5*6+8*6+9.5*6+10*6+10*3+9*3+8.5*3+7.5*3
369/42
devtools::build()
devtools::check()
devtools::check()
devtools::load_all()
# Run the Go-No Go Task
gonogo(id = "my_name", # specify participant's name or id
n_trial = 10, # specify number of trials
stimuli = c("A", "X"), # specify Go and No Go stimuli (in that order)
inter = .6, # specify length of each trial
prb = c(.7, .3)) # specify the probability weights of Go and No Go stimuli (in that order)
gonogo(id = "my_name", # specify participant's name or id
n_trial = 10, # specify number of trials
stimuli = c("A", "X"), # specify Go and No Go stimuli (in that order)
inter = .6, # specify length of each trial
prb = c(.7, .3))
gonogo(id = "my_name", # specify participant's name or id
n_trial = 10, # specify number of trials
stimuli = c("A", "X"), # specify Go and No Go stimuli (in that order)
inter = .6, # specify length of each trial
prb = c(.7, .3)) -> "p1_data"
gonogo(id = "my_name", # specify participant's name or id
n_trial = 10, # specify number of trials
stimuli = c("A", "X"), # specify Go and No Go stimuli (in that order)
inter = .6, # specify length of each trial
prb = c(.7, .3)) -> "p1_data"
gonogo(id = "my_name", # specify participant's name or id
n_trial = 10, # specify number of trials
stimuli = c("A", "X"), # specify Go and No Go stimuli (in that order)
inter = .7, # specify length of each trial
prb = c(.7, .3)) -> "p1_data"
gonogo(id = "my_name", # specify participant's name or id
n_trial = 10, # specify number of trials
stimuli = c("A", "X"), # specify Go and No Go stimuli (in that order)
inter = .7, # specify length of each trial
prb = c(.7, .3)) -> "p1_data"
print(p1_data)
print(p1_data)
# Look at data
print(p1_data)
getwd()
knitr::include_graphics(path = "C:/Users/Omistaja/OneDrive/Tiedostot/GitHub/theprojectofmilla/gonogo/example_data.jpg")
library(magick)
img_url <- "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/SNice.svg/640px-SNice.svg.png"
pic <- image_read(img_url)
print(pic)
?print
print(pic, width = 100)
image_scale(image_scale(pic,"50%"),"80%")
image_scale(image_scale(pic,"30%"),"70%")
image_scale(image_scale(pic,"30%"))
image_scale(image_scale(pic,"20%"))
image_scale(image_scale(pic,"15%"))
pic1
pic1 <- image_read(img_url1)
img_url1 <- "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/SNice.svg/640px-SNice.svg.png"
img_url2 <- "https://clipart.world/wp-content/uploads/2021/04/Sad-Face-Emoji-clipart-free.png"
pic1 <- image_read(img_url1)
pic2 <- image_read(img_url2)
pic1
pic1$width
pic1[[1]]
pic1[1]
pic1[1][[2]]
pic1[1][2]
pic1[1]
summary(pic1)
pic1["width"]
image_read("https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/SNice.svg/640px-SNice.svg.png")
image_read("https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/SNice.svg/640px-SNice.svg.png", width = 100)
image_read_svg("https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/SNice.svg/640px-SNice.svg.png")
image_read_svg("https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Mr._Smiley_Face.svg/414px-Mr._Smiley_Face.svg.png")
install.packages("rsvg")
image_read_svg("https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Mr._Smiley_Face.svg/414px-Mr._Smiley_Face.svg.png")
pic1
image_scale(pic1,"382x509!")
image_scale(pic1,"100x100!")
class("https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/Mr._Smiley_Face.svg/414px-Mr._Smiley_Face.svg.png")
pic1[1]
image_scale(pic1,"100x100!")
image_scale(pic1,"100x100!")
drawScreen("A", 3)
drawScreen <- function(txt, cex=1, col="black") {
plot(x=NA, y=NA, xlim=c(0,1), ylim=c(0,1), xaxt="n", yaxt="n", xlab="", ylab="")
text(x=0.5, y=0.5, labels=txt, cex=cex)
}
drawScreen("A", 3)
drawscreen(image_scale(pic1,"100x100!"))
drawScreen(image_scale(pic1,"100x100!"))
drawScreen("A", 3)
image_scale(pic1,"100x100!")
drawScreen("A", 3)
plot(pic1)
plot(x=NA, y=NA, xlim=c(0,1), ylim=c(0,1), xaxt="n", yaxt="n", xlab="", ylab="")
plot(pic1, x=NA, y=NA, xlim=c(0,1), ylim=c(0,1), xaxt="n", yaxt="n", xlab="", ylab="")
plot(pic1, xlim=c(0,1), ylim=c(0,1), xaxt="n", yaxt="n", xlab="", ylab="")
#'
#'
#' @param choiceKeys A character vector specifying the choice key(s) for which the reaction time is recorded
#'
#' @param interval A numeric vector of length 1 specifying the length of each trial in seconds (default is 1)
#'
#' @return Response (either choice key pressed, or NA) and reaction time in seconds (NA if choice key not pressed)
#' @export
#'
#' @examples
rrt <- function(choiceKeys=c(" "), interval = 0.6) {
dynamic_readline <- function() {
# Create a counter variable that breaks the loop
x <- 0
while (rstudioapi::isAvailable()) {
input <- rstudioapi::getConsoleEditorContext()$contents
# Increase counter variable
>>>>>>> Stashed changes
x <- x + 1
if (input != "") {
rstudioapi::sendToConsole("", execute = FALSE)
return(input)
}
if (x == 5) {
return("none")
}
}
readline()
}
<<<<<<< Updated upstream
rt <- Sys.time()
repeat {
choice <- dynamic_readline()
if (choice %in% choiceKeys) {
rt <- Sys.time() - rt
break
}
elapsed_time <- Sys.time() - rt
if (elapsed_time > interval) {
rt <- NA
break
}
}
setNames(c(choice, rt), c("response", "rt"))
}
update_data <- function(data, stimuli = stimuli) {
# Replace " " with "space"
for (i in 1:nrow(data)) {
if (data$response[i] == " ") {
data$response[i] <- "space"
}
}
# Subtract the mean error (time it takes to run the function rrt() from a
# simulation of 1000 trials) from the reaction times for increased accuracy
mean_error <- 0.02742448
data$rt <- as.numeric(data$rt)
for (i in 1:nrow(data)) {
if (!is.na(data$rt[i])) { # think about the second condition
data[i, "rt"] <- data[i, "rt"]-mean_error
}
}
# Update the correct and SDT columns
for (i in 1:nrow(data)) {
if (data[i, "stimulus"] == stimuli[1] && data[i, "response"] == "space") {
data[i, "correct"] <- 1
data[i, "SDT"] <- "hit"
} else if (data[i, "stimulus"] == stimuli[2] && data[i, "response"] == "space") {
data[i, "correct"] <- 0
data[i, "SDT"] <- "falsealarm"
} else if (data[i, "stimulus"] == stimuli[1] && data[i, "response"] != "space") {
data[i, "correct"] <- 0
data[i, "SDT"] <- "miss"
} else {
data[i, "correct"] <- 1
data[i, "SDT"] <- "correctrejection"
}
}
return(data)
}
gonogo <- function(id, n_trial = 40, n_block = 4, stimuli = c("A", "X"),
inter = 0.6, prb = c(0.75, 0.25)) {
# Check class and length of arguments
if (!(class(id) %in% c("character", "numeric")) || length(id) != 1) {
stop("id must be either a numeric vector of length 1 (pin number identifying the participant), or a character vector of length 1 (name of participant)")
}
if (class(n_trial) != "numeric" || length(n_trial) != 1) {
stop("n_trial must be a numeric vector of length 1")
}
if (class(n_block) != "numeric" || length(n_block) != 1) {
stop("n_block must be a numeric vector of length 1")
}
if (class(stimuli) != "character" || length(stimuli) != 2) {
stop("stimuli must be a character vector of length 2")
}
if (class(inter) != "numeric" || length(inter) != 1) {
stop("inter must be a numeric vector of length 1")
}
if (class(prb) != "numeric" || length(prb) != 2 || prb[1] + prb[2] != 1) {
stop("prb must be a numeric vector of length 2, and its components must add up to 1")
}
# Create practice stimuli
practice <- sample(x = stimuli, size = 10, replace = TRUE)
# Create separate dataframes for each block
all_data <- list()
for (j in 1:n_block) {
all_data[[j]] <- data.frame(id = factor(rep(id, n_trial),
levels = c(id)),
response = factor(rep("none", n_trial),
levels = c(" ",
"none",
"space")),
correct = rep(2, n_trial),
SDT = factor(rep("hit", n_trial),
levels = c("hit",
"miss",
"falsealarm",
"correctrejection")),
rt = rep(100, n_trial),
stimulus = sample(x = stimuli,
size = n_trial,
prob = prb,
replace = TRUE),
block = rep(j, n_trial)
)
}
# Intro screens
drawScreen(paste("Welcome to the Go-No Go Task", id,"!\nPress Enter to continue."), cex = 1.3)
readline()
drawScreen(paste("Instructions \nIn this task, you will see two types of stimuli,", stimuli[1], "and\n", stimuli[2], ". When you see", stimuli[1], "you should respond as quickly as\npossible by pressing the space bar. When you see", stimuli[2], "you should\nnot respond (do not press any key). You should try to be as fast and accurate\nas possible. Press Enter to continue."),
cex = 0.75)
readline()
drawScreen(paste("The task consists of", n_block, "blocks, each consisting of", n_trial, "trials.\nThere is is a break between each pair of blocks.\nBefore starting the task, there is one practice block of 10 trials.\n Press Enter to start the practice trials."),
cex = 0.75)
readline()
drawScreen("")
Sys.sleep(0.5)
# Practice trials
drawScreen("Practice trials")
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (p in 1:10) {
drawScreen(practice[p], 3)
rrt(choiceKeys = c(" "), interval = inter)
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
drawScreen("")
Sys.sleep(0.1)
}
drawScreen("End of practice trials.\nPress Enter to continue on to the task.",
cex = 1)
readline()
# The for loops
for (j in 1:n_block) {
drawScreen(paste("Block", j))
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (i in 1:n_trial) {
drawScreen(all_data[[j]][i, "stimulus"], 3)
all_data[[j]][i, c("response", "rt")] <- rrt(choiceKeys = c(" "),
interval = inter)
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
drawScreen("")
Sys.sleep(0.1)
}
drawScreen(paste("End of Block", j, "!\n Press Enter to continue."),
cex = 1)
readline()
}
# End screen
drawScreen(paste("You finished the task. Thank you for participating",id,"!"), cex = 1)
# Bind the datasets
for (k in 1:(length(all_data)-1)) {
all_data[[k+1]] <- rbind(all_data[[k]], all_data[[k+1]])
}
data <- all_data[[length(all_data)]]
# Update the dataset
data <- update_data(data, stimuli = stimuli)
print(data)
}
# Ideas?
# can you break up the function into smaller bits?
# make code prettier
# specify what rt=NA means / how it works
# function for detecting unrealistic reaction times after data set is done? / message?
# function for changing the data set (last bit of code)?
# change all documentation + testing
# delete the rrt_mean_error function
gonogo(id = "Milla", n_trial = 10, n_block = 3, inter = 0.5)
gonogo(id = "Milla", n_trial = 10, n_block = 3)
gonogo <- function(id, n_trial = 40, n_block = 4, stimuli = c("A", "X"),
inter = 0.6, prb = c(0.75, 0.25)) {
# Check class and length of arguments
if (!(class(id) %in% c("character", "numeric")) || length(id) != 1) {
stop("id must be either a numeric vector of length 1 (pin number identifying the participant), or a character vector of length 1 (name of participant)")
}
if (class(n_trial) != "numeric" || length(n_trial) != 1) {
stop("n_trial must be a numeric vector of length 1")
}
if (class(n_block) != "numeric" || length(n_block) != 1) {
stop("n_block must be a numeric vector of length 1")
}
if (class(stimuli) != "character" || length(stimuli) != 2) {
stop("stimuli must be a character vector of length 2")
}
if (class(inter) != "numeric" || length(inter) != 1) {
stop("inter must be a numeric vector of length 1")
}
if (class(prb) != "numeric" || length(prb) != 2 || prb[1] + prb[2] != 1) {
stop("prb must be a numeric vector of length 2, and its components must add up to 1")
}
# Create practice stimuli
practice <- sample(x = stimuli, size = 10, replace = TRUE)
# Create separate dataframes for each block
all_data <- list()
for (j in 1:n_block) {
all_data[[j]] <- data.frame(id = factor(rep(id, n_trial),
levels = c(id)),
response = factor(rep("none", n_trial),
levels = c(" ",
"none",
"space")),
correct = rep(2, n_trial),
SDT = factor(rep("hit", n_trial),
levels = c("hit",
"miss",
"falsealarm",
"correctrejection")),
rt = rep(100, n_trial),
stimulus = sample(x = stimuli,
size = n_trial,
prob = prb,
replace = TRUE),
block = rep(j, n_trial)
)
}
# Intro screens
drawScreen(paste("Welcome to the Go-No Go Task", id,"!\nPress Enter to continue."), cex = 1.3)
readline()
drawScreen(paste("Instructions \nIn this task, you will see two types of stimuli,", stimuli[1], "and\n", stimuli[2], ". When you see", stimuli[1], "you should respond as quickly as\npossible by pressing the space bar. When you see", stimuli[2], "you should\nnot respond (do not press any key). You should try to be as fast and accurate\nas possible. Press Enter to continue."),
cex = 0.75)
readline()
drawScreen(paste("The task consists of", n_block, "blocks, each consisting of", n_trial, "trials.\nThere is is a break between each pair of blocks.\nBefore starting the task, there is one practice block of 10 trials.\n Press Enter to start the practice trials."),
cex = 0.75)
readline()
drawScreen("")
Sys.sleep(0.5)
# Practice trials
drawScreen("Practice trials")
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (p in 1:10) {
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
drawScreen("")
Sys.sleep(0.1)
drawScreen(practice[p], 3)
rrt(choiceKeys = c(" "), interval = inter)
}
drawScreen("End of practice trials.\nPress Enter to continue on to the task.",
cex = 1)
readline()
# The for loops
for (j in 1:n_block) {
drawScreen(paste("Block", j))
Sys.sleep(1)
drawScreen("Countdown: 3")
Sys.sleep(1)
drawScreen("Countdown: 2")
Sys.sleep(1)
drawScreen("Countdown: 1")
Sys.sleep(1)
drawScreen("")
Sys.sleep(0.5)
for (i in 1:n_trial) {
drawScreen("")
Sys.sleep(0.1)
drawScreen("+", 3)
Sys.sleep(0.4)
drawScreen("")
Sys.sleep(0.1)
drawScreen(all_data[[j]][i, "stimulus"], 3)
all_data[[j]][i, c("response", "rt")] <- rrt(choiceKeys = c(" "),
interval = inter)
}
drawScreen(paste("End of Block", j, "!\n Press Enter to continue."),
cex = 1)
readline()
}
# End screen
drawScreen(paste("You finished the task. Thank you for participating",id,"!"), cex = 1)
# Bind the datasets
for (k in 1:(length(all_data)-1)) {
all_data[[k+1]] <- rbind(all_data[[k]], all_data[[k+1]])
}
data <- all_data[[length(all_data)]]
# Update the dataset
data <- update_data(data, stimuli = stimuli)
print(data)
}
gonogo(id = 12, n_trial = 5, n_block = 3)
devtools::document()
devtools::document()
devtools::load_all()
devtools::build()
devtools::load_all()
gonogo(id = "Milla", n_trial = 20, n_block = 2)
data<-gonogo(id = "Milla")
dtaa$rt
data$rt
hist(data$rt)
sort(daya$rt)
sort(data$rt)
which(data$rt < 0)
sort(data$rt)
is.na(data$rt)
sum(is.na(data$rt))
sum(!is.na(data$rt))
sort(data$rt)
(-0.018445636) + 0.014460470
0.018445636 - 0.014460470
sort(data$rt)[1]
i<-1
abs(abs(sort(data$rt)[i+1]) - abs(sort(data$rt)[i]))
i<-10
abs(abs(sort(data$rt)[i+1]) - abs(sort(data$rt)[i]))
range(data$rt)
range(data$rt, na.rm = T)
-0.003249551 - 0.337513541
range(data$rt, na.rm = TRUE)
abs(range(data$rt, na.rm = TRUE)[1] - range(data$rt, na.rm = TRUE)[2])
threshold <- 1/3 * abs(range(data$rt, na.rm = TRUE)[1] - range(data$rt, na.rm = TRUE)[2])
abs(range(data$rt, na.rm = TRUE)[1] - range(data$rt, na.rm = TRUE)[2])
threshold <- 1/3 * abs(range(data$rt, na.rm = TRUE)[1] - range(data$rt, na.rm = TRUE)[2])
dist <- c()
for (i in 1:(sum(!is.na(data$rt))-1)) {
dist[i] <- abs(sort(data$rt)[i+1] - sort(data$rt)[i])
}
sum(dist >= threshold)
dist
whihc(dist >= threshold)
which(dist >= threshold)
dist[4]
(sum(data$rt < 0))
(sum(data$rt < 0, na.rm = TRUE))
which(data$rt < 0)
hist(dist)
hist(dist[-4])
?gonogo
?gonogo::gonogo
devtools::document()
devtools::build()
devtools::load_all()
devtools::load_all()
devtools::load_all()
=======
o_rt <- Sys.time()
repeat {
choice <- dynamic_readline()
if (choice %in% choiceKeys){
o_rt <- Sys.time() - o_rt
break
}
elapsed_time <- Sys.time() - o_rt
if (elapsed_time > interval) {
o_rt <- 100
break
}
}
setNames(c(choice, o_rt), c("response", "rt"))
}
rrt()
rrt()
library(shiny); runApp('C:/Users/Omistaja/AppData/Local/Packages/microsoft.windowscommunicationsapps_8wekyb3d8bbwe/LocalState/Files/S0/24543/Attachments/shiny_example_rt[28023].R')
runApp('R/shiny_attempt.R')
runApp('R/shiny_attempt.R')
runApp('R/shiny_attempt.R')
# Game parameters (don't think these should be set beforehand though? I want participant to decide on them)
interval <- 0.6
n_trial <- 10
prb <- c(0.7, 0.3)
stim <- c("A", "X")
stimuli <- sample(stim, size = n_trial, replace = TRUE)
runApp('R/shiny_attempt.R')
interval <- 0.6
n_trial <- 10
prb <- c(0.7, 0.3)
stim <- c("A", "X")
stimuli <- sample(stim, size = n_trial, replace = TRUE)
ui <- fixedPage(
title = "Go No-Go Task",
uiOutput("MainAction"),
#tags$style(type = "text/css", ".recalculating {opacity: 1.0;}") # prevents grey screen during Sys.sleep()
)
server <- function(input, output, session) {
# Define Reactive Values (the main values in the game)
CurrentValues <- reactiveValues(page = "welcome",
training = TRUE,
lastPress = Sys.time(),
trial = 0,
rt = 0,
stimulus = NULL,
response = NULL)
# GameData stores vectors of histories
GameData <- reactiveValues(trial = c(),
rt = c(),
stimulus = c(),
lastPress = c(),
response = c())
# Page Layout
PageLayouts <- reactive({
# Welcome page
if (CurrentValues$page == "welcome") {
inputLabel <- p("Please enter your name or a unique ID")
}
return(
list(
h1("Go No-Go Task"),
p("This is a version of the Go-No Go Task implemented in Shiny. The task measures inhibitory control, a cognitive process that enables humans to cancel motor activity after its initiation."),
p("If you wish to continue, please enter your name or a unique ID number"),
textInput(inputId = "workerid",
label = inputLabel,
placeholder = "e.g., participant 1"),
actionButton(inputId = "gt_inst1",
label = "Start!")
)
)
# Instructions
if (CurrentValues$page == "inst1") {
return(
list(
h1("The Go-No Go Task"),
p("Some instructions go here"),
actionButton(inputId = "gt_training",
label = "Start the task")
)
)}
}
# Game
# if (currentValues$page == "game") {
#
# }
)
}
# server <- function(input, output, session) {
#
#   click_timestamps <- reactiveVal(NULL)
#   recorded_rts <- reactiveVal(NULL)
#
#   observeEvent(input$button, {
#     new_val <- append(click_timestamps(), Sys.time())
#
#     # set click timestamp
#     click_timestamps(new_val)
#
#     if(length(new_val) == 2) {
#
#       duration <- as.numeric(difftime(new_val[2], new_val[1], units = "secs"))
#       recorded_rts(c(recorded_rts(), duration))
#
#       print(recorded_rts)
#       print(click_timestamps)
#
#       # reset click timestamp
#       click_timestamps(NULL)
#     }
#   })
#
#   output$table <- renderTable(
#     if (length(recorded_rts()) > 0) {
#       return(data.frame(n = seq_along(recorded_rts()), rt = recorded_rts()))
#     } else {
#       return(data.frame(n = "-", rt = "-"))
#     }
#
#   )
#   output$plot <- renderPlot(
#     if (length(recorded_rts()) > 0)
#       hist(recorded_rts())
#     else
#       plot(1, type="n", xlab="", ylab="", xlim=c(0, 10), ylim=c(0, 10))
#   )
#
# }
#
shinyApp(ui, server)
devtools::load_
devtools::load_all()
devtools::build()
>>>>>>> Stashed changes
